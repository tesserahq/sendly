---
description: Use this rule when generating or updating API routers. It enforces a consistent response format ({"data": [...]}), prevents redundant foreign keys in request bodies, and promotes clean multi-tenant patterns. Always validate parent scope (e.g., workspace) via the URL, not the payload.
globs: 
alwaysApply: false
---
In the routers directory:

* Create a file named <model>_router.py
* Define an APIRouter instance with:
* prefix="/<model_plural>" or for nested: prefix="/workspaces/{workspace_id}/<model_plural>"
* tags=["<Model>"]

Endpoints:

* GET / – list all items, returns { "data": [...] }
* GET /{id} – retrieve a specific item by ID
* POST / – create a new item
* PUT /{id} – update an existing item
* DELETE /{id} – delete an item

For nested resources: only collection routes are nested under the parent. Item routes (GET/PUT/DELETE by id) are global and must NOT include the parent prefix.

Nested collection routes:
* GET /<parent_plural>/{parent_id}/<resource_plural>
* POST /<parent_plural>/{parent_id}/<resource_plural>

Global item routes:
* GET /<resource_plural>/{id}
* PUT /<resource_plural>/{id}
* DELETE /<resource_plural>/{id}

Implementation:

* Use the corresponding service (<Model>Service) for database interaction
* Use Pydantic schemas for validation (<Model>CreateRequest, <Model>Update)
* For nested resources, do not include the parent_id (e.g., workspace_id) in the request body schema if it’s in the URL

Nested Resources

* Use prefix="/<parent_plural>/{parent_id}/<resource_plural>"
* Accept parent_id as a path parameter in each route function
* Always call a scoped dependency like get_workspace_by_id(workspace_id, db) at the start of the route to:
  * Validate the parent exists
  * Enforce access control and scope
* Inject parent_id manually into service-layer calls, not the request body

Allowed routes for a nested resource (example: Author under Workspace)

Generate these endpoints:
* GET /workspaces/{workspace_id}/authors  – List authors
* POST /workspaces/{workspace_id}/authors – Create author
* GET /authors/{author_id}               – Get author
* PUT /authors/{author_id}               – Update author
* DELETE /authors/{author_id}            – Delete author

Do NOT generate these nested item routes:
* GET /workspaces/{workspace_id}/authors/{author_id}
* PUT /workspaces/{workspace_id}/authors/{author_id}
* DELETE /workspaces/{workspace_id}/authors/{author_id}

```python
@router.post("/", response_model=CredentialRead)
def create_credential(
    workspace_id: UUID,
    data: CredentialCreateRequest,
    db: Session = Depends(get_db),
):
    workspace = get_workspace_by_id(workspace_id, db)
    return CredentialService(db).create_credential(data, workspace_id=workspace.id)

@public_router.get("/authors/{author_id}", response_model=CredentialRead)
def get_author(author_id: UUID, db: Session = Depends(get_db)):
    return AuthorService(db).get_by_id(author_id)

# Similarly define PUT /authors/{author_id} and DELETE /authors/{author_id} on the global router (no workspace prefix).
```